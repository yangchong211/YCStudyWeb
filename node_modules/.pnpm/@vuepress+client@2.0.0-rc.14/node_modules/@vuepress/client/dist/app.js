import {
  ClientOnly,
  Content,
  RouteLink,
  clientDataSymbol,
  redirects,
  resolveRoute,
  resolvers,
  routes,
  updateHeadSymbol,
  usePageHead,
  usePageLang,
  usePageLayout,
  withBase
} from "./chunk-YRXAAVF4.js";

// src/app.ts
import { clientConfigs } from "@internal/clientConfigs";
import { createApp, createSSRApp, h } from "vue";

// src/internal/siteData.ts
import { siteData as siteDataRaw } from "@internal/siteData";
import { shallowRef } from "vue";
var siteData = shallowRef(siteDataRaw);
if (__VUEPRESS_DEV__ && (import.meta.webpackHot || import.meta.hot)) {
  __VUE_HMR_RUNTIME__.updateSiteData = (data) => {
    siteData.value = data;
  };
}

// src/router/createVueRouter.ts
import { removeEndingSlash } from "@vuepress/shared";
import {
  createMemoryHistory,
  createRouter,
  createWebHistory,
  START_LOCATION
} from "vue-router";
var historyCreator = __VUEPRESS_SSR__ ? createMemoryHistory : createWebHistory;
var createVueRouter = () => {
  const router = createRouter({
    // it might be an issue of vue-router that have to remove the ending slash
    history: historyCreator(removeEndingSlash(__VUEPRESS_BASE__)),
    routes: [
      {
        name: "vuepress-route",
        path: "/:catchAll(.*)",
        components: {}
      }
    ],
    scrollBehavior: (to, _from, savedPosition) => {
      if (savedPosition) return savedPosition;
      if (to.hash) return { el: to.hash };
      return { top: 0 };
    }
  });
  router.beforeResolve(async (to, from) => {
    if (to.path !== from.path || from === START_LOCATION) {
      const route = resolveRoute(to.fullPath);
      if (route.path !== to.fullPath) {
        return route.path;
      }
      const pageChunk = await route.loader();
      to.meta = {
        // attach route meta
        ...route.meta,
        // attach page chunk route meta
        _pageChunk: pageChunk
      };
    } else if (to.path === from.path) {
      to.meta = from.meta;
    }
  });
  return router;
};

// src/setupGlobalComponents.ts
var setupGlobalComponents = (app) => {
  app.component("ClientOnly", ClientOnly);
  app.component("Content", Content);
  app.component("RouteLink", RouteLink);
};

// src/setupGlobalComputed.ts
import { computed, customRef } from "vue";
var setupGlobalComputed = (app, router, clientConfigs2) => {
  const routePath = computed(() => router.currentRoute.value.path);
  const pageChunk = customRef((track, trigger) => ({
    get() {
      track();
      return router.currentRoute.value.meta._pageChunk;
    },
    set(value) {
      router.currentRoute.value.meta._pageChunk = value;
      trigger();
    }
  }));
  if (__VUEPRESS_DEV__ && (import.meta.webpackHot || import.meta.hot)) {
    __VUE_HMR_RUNTIME__.updatePageData = async (newPageData) => {
      const oldPageChunk = await routes.value[newPageData.path].loader();
      const newPageChunk = { comp: oldPageChunk.comp, data: newPageData };
      routes.value[newPageData.path].loader = () => Promise.resolve(newPageChunk);
      if (newPageData.path === router.currentRoute.value.meta._pageChunk?.data.path) {
        pageChunk.value = newPageChunk;
      }
    };
  }
  const layouts = computed(() => resolvers.resolveLayouts(clientConfigs2));
  const routeLocale = computed(
    () => resolvers.resolveRouteLocale(siteData.value.locales, routePath.value)
  );
  const siteLocaleData = computed(
    () => resolvers.resolveSiteLocaleData(siteData.value, routeLocale.value)
  );
  const pageComponent = computed(() => pageChunk.value.comp);
  const pageData = computed(() => pageChunk.value.data);
  const pageFrontmatter = computed(() => pageData.value.frontmatter);
  const pageHeadTitle = computed(
    () => resolvers.resolvePageHeadTitle(pageData.value, siteLocaleData.value)
  );
  const pageHead = computed(
    () => resolvers.resolvePageHead(
      pageHeadTitle.value,
      pageFrontmatter.value,
      siteLocaleData.value
    )
  );
  const pageLang = computed(
    () => resolvers.resolvePageLang(pageData.value, siteLocaleData.value)
  );
  const pageLayout = computed(
    () => resolvers.resolvePageLayout(pageData.value, layouts.value)
  );
  const clientData = {
    layouts,
    pageData,
    pageComponent,
    pageFrontmatter,
    pageHead,
    pageHeadTitle,
    pageLang,
    pageLayout,
    redirects,
    routeLocale,
    routePath,
    routes,
    siteData,
    siteLocaleData
  };
  app.provide(clientDataSymbol, clientData);
  Object.defineProperties(app.config.globalProperties, {
    $frontmatter: { get: () => pageFrontmatter.value },
    $head: { get: () => pageHead.value },
    $headTitle: { get: () => pageHeadTitle.value },
    $lang: { get: () => pageLang.value },
    $page: { get: () => pageData.value },
    $routeLocale: { get: () => routeLocale.value },
    $site: { get: () => siteData.value },
    $siteLocale: { get: () => siteLocaleData.value },
    $withBase: { get: () => withBase }
  });
  return clientData;
};

// src/setupUpdateHead.ts
import { isPlainObject, isString } from "@vuepress/shared";
import { onMounted, provide, useSSRContext, watch } from "vue";
var setupUpdateHead = () => {
  const head = usePageHead();
  const lang = usePageLang();
  if (__VUEPRESS_SSR__) {
    const ssrContext = useSSRContext();
    if (ssrContext) {
      ssrContext.head = head.value;
      ssrContext.lang = lang.value;
    }
    return;
  }
  let managedHeadElements = [];
  const takeOverHeadElements = () => {
    head.value.forEach((item) => {
      const headElement = queryHeadElement(item);
      if (headElement) {
        managedHeadElements.push(headElement);
      }
    });
  };
  const generateHeadElements = () => {
    const result = [];
    head.value.forEach((item) => {
      const headElement = createHeadElement(item);
      if (headElement) {
        result.push(headElement);
      }
    });
    return result;
  };
  const updateHead = () => {
    document.documentElement.lang = lang.value;
    const newHeadElements = generateHeadElements();
    managedHeadElements.forEach((oldEl, oldIndex) => {
      const matchedIndex = newHeadElements.findIndex(
        (newEl) => oldEl.isEqualNode(newEl)
      );
      if (matchedIndex === -1) {
        oldEl.remove();
        delete managedHeadElements[oldIndex];
      } else {
        newHeadElements.splice(matchedIndex, 1);
      }
    });
    newHeadElements.forEach((el) => document.head.appendChild(el));
    managedHeadElements = [
      // filter out empty deleted items
      ...managedHeadElements.filter((item) => !!item),
      ...newHeadElements
    ];
  };
  provide(updateHeadSymbol, updateHead);
  onMounted(() => {
    if (!__VUEPRESS_DEV__) {
      takeOverHeadElements();
    }
    watch(head, updateHead, { immediate: __VUEPRESS_DEV__ });
  });
};
var queryHeadElement = ([
  tagName,
  attrs,
  content = ""
]) => {
  const attrsSelector = Object.entries(attrs).map(([key, value]) => {
    if (isString(value)) {
      return `[${key}=${JSON.stringify(value)}]`;
    }
    if (value === true) {
      return `[${key}]`;
    }
    return "";
  }).join("");
  const selector = `head > ${tagName}${attrsSelector}`;
  const headElements = Array.from(
    document.querySelectorAll(selector)
  );
  const matchedHeadElement = headElements.find(
    (item) => item.innerText === content
  );
  return matchedHeadElement || null;
};
var createHeadElement = ([
  tagName,
  attrs,
  content
]) => {
  if (!isString(tagName)) {
    return null;
  }
  const headElement = document.createElement(tagName);
  if (isPlainObject(attrs)) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (isString(value)) {
        headElement.setAttribute(key, value);
      } else if (value === true) {
        headElement.setAttribute(key, "");
      }
    });
  }
  if (isString(content)) {
    headElement.appendChild(document.createTextNode(content));
  }
  return headElement;
};

// src/app.ts
var appCreator = __VUEPRESS_DEV__ ? createApp : createSSRApp;
var createVueApp = async () => {
  const app = appCreator({
    name: "Vuepress",
    setup() {
      setupUpdateHead();
      for (const clientConfig of clientConfigs) {
        clientConfig.setup?.();
      }
      const rootComponents = clientConfigs.flatMap(
        ({ rootComponents: rootComponents2 = [] }) => rootComponents2.map((component) => h(component))
      );
      const pageLayout = usePageLayout();
      return () => [h(pageLayout.value), rootComponents];
    }
  });
  const router = createVueRouter();
  setupGlobalComponents(app);
  const globalComputed = setupGlobalComputed(app, router, clientConfigs);
  if (__VUEPRESS_DEV__ || __VUE_PROD_DEVTOOLS__) {
    const { setupDevtools } = await import("./setupDevtools-HHDGOOYC.js");
    setupDevtools(app, globalComputed);
  }
  for (const clientConfig of clientConfigs) {
    await clientConfig.enhance?.({ app, router, siteData });
  }
  app.use(router);
  return {
    app,
    router
  };
};
if (!__VUEPRESS_SSR__) {
  createVueApp().then(({ app, router }) => {
    router.isReady().then(() => {
      app.mount("#app");
    });
  });
}
export {
  createVueApp
};
